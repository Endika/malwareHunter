#!/usr/bin/python
# Copyright (C) 2014 Amri Abdesslem
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# [NOTES] -----------------------------------------------------------
# 1) If you're running VirtualBox on Windows, you'll need win32com, which is
#    included in the Python Extensions for Windows package
#--------------------------------------------------------------------

__author__ = 'ask3m'

#--------------------------------------------------------------------

import sys, os, time, glob, shutil
from optparse import OptionParser
import subprocess

# -----------------------------------------------------------------------

vm_paths = {
    # the standard path on Mac OS X
    '/Library/Application Support/VMware Fusion/vmrun': 'fusion',
    # the standard path on Linux
    '/usr/bin/vmrun': 'ws',
    # the standard path on Windows
    'C:\\Program Files\\VMware\\VMware Workstation\\vmrun.exe': 'ws',
    }

def pinfo(msg):
    print "[INFO] ", msg

def perror(msg):
    print "[ERROR] ", msg

# -----------------------------------------------------------------------

class VBoxAuto:
    status="ON"
    def __init__(self, machine):
        self.machine = machine
        self.ctx    = {}
        self.mach   = None
        self.session=None
       
    def get_mach(self):
        return self.ctx['global'].getArray(self.ctx['vb'], 'machines')
       
    def check(self):
   
        try:
            from vboxapi import VirtualBoxManager
        except ImportError:
            perror('You need to install VirtualBox!')
            return False
           
        vbm = VirtualBoxManager(None, None)
   
        self.ctx = {'global':vbm,
                    'const' :vbm.constants,
                    'vb'    :vbm.vbox,
                    'mgr'   :vbm.mgr}
   
        # the machine name or id must be valid
       
        for m in self.get_mach():
            if m.name == self.machine or m.id == self.machine:
                self.mach = m
                break
               
        if self.mach == None:
            perror('Cannot find the machine: %s' % self.machine)
            return False
           
        pinfo('Using %s (uuid: %s)' % (self.mach.name, self.mach.id))
           
        pinfo('Session state: %s' % self.get_const(
            "SessionState", self.mach.sessionState))
        pinfo('Machine state: %s' % self.get_const(
            "MachineState", self.mach.state))
        status=self.mach.state
        return True
       
    def get_const(self, enum, elem):
        # this lookup fails on Python2.6 - if that happens
        # then just return the element number
        try:
            all = self.ctx['const'].all_values(enum)
            for e in all.keys():
                if str(elem) == str(all[e]):
                    return e
        except:
            return '%d' % elem
       
    def list(self):
        try:
            for m in self.get_mach():
                print "%-12s %s (state:%s/%s)" %(m.name, m.id,
                    self.get_const("MachineState", m.state),
                    self.get_const("SessionState", m.sessionState))
        except:
            perror('No machines. Did you call check() first?')
   
    def start(self, nsecwait=60):
        vb      = self.ctx['vb']
        self.session = self.ctx['mgr'].getSessionObject(vb)
        #p = vb.openRemoteSession(session, self.mach.id, 'gui', '')
        mach=vb.findMachine(self.machine)
        p= mach.launchVMProcess(self.session,"gui","")
        #headless
        while not p.completed:
            p.waitForCompletion(1000)
            self.ctx['global'].waitForEvents(0)
       
        if int(p.resultCode) == 0:
            print "close"
            #session.console.powerDown()
            #session.close()
        else:
           perror('Cannot start machine!')
           
        pinfo('Waiting %d seconds to boot...' % nsecwait)
        time.sleep(nsecwait)

    def opensession(self):
        session = self.ctx['global'].openMachineSession(self.mach.id)
        mach = session.machine
        return (session, mach)
   
    def closesession(self, session):
        self.ctx['global'].closeMachineSession(session)
        time.sleep(5)
   
    def stop(self):
        (session, mach) = self.opensession()
        pinfo('Powering down the system')
        try:
            session.console.powerDown()
            time.sleep(5)
            self.closesession(session)
        except Exception, e:
            pinfo(e)
       
    def revert(self, snapname):
        # Revert a VM to the specified snapshot
        (session, mach) = self.opensession()
        pinfo("Reverting to snapshot '%s'" % snapname)
        try:
            snap = mach.findSnapshot(snapname)
            session.console.restoreSnapshot(snap)
            time.sleep(5)
            self.closesession(session)
        except Exception, e:
            pinfo(e)
   
    def winexec(self, user, passwd, args):
        print "okk"
        #session = self.ctx['mgr'].getSessionObject()
        #(session, mach) = self.opensession()
        try:
            argstr = ' '.join(args[1:])
        except:
            argstr = ''
        pinfo("Executing '%s' with args '%s'" % (args[0], argstr))
        pinfo("If this set fails, set up autologin for your user.")
        env = []
        ret = self.session.console.guest.executeProcess(
            args[0],
            0,
            args,
            env,
            user, passwd, 0)    
        # on Windows, executeProcess returns an IProgress instance  
        if os.name == "nt":
            pid = ret[3]
        else:
            pid = ret[1]
        pinfo('Process ID: %d' % pid)
     
# -----------------------------------------------------------------------

def main(argv):
    print 'Nothing to do. Import me!'
    return 0

if __name__ == '__main__':
    main(sys.argv)

